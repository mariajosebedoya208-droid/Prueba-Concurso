# -*- coding: utf-8 -*-
"""Analisis_Portafolios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OHRI3VCCTIOc3M4eLd18hLDRVqrlBv_n
"""

!pip install streamlit pandas numpy yfinance matplotlib

#Importaci√≥n las librer√≠as

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt

# Encabezado principal

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt

st.title ("üíº Smart Portafolio")
st.write("""
Esta aplicaci√≥n analiza un portafolio de inversi√≥n aplicando la **Teor√≠a Moderna de Portafolios de Markowitz**.
Se simulan tres escenarios (Conservador, Moderado y Agresivo) para observar c√≥mo var√≠an el riesgo, el rendimiento y la composici√≥n de activos.
Los datos se obtienen directamente desde **Yahoo Finance**, y los activos seleccionados pertenecen al sector tecnol√≥gico.
""")

# Configuraci√≥n de entradas

st.sidebar.header("‚öôÔ∏è Configuraci√≥n del an√°lisis")

lista_tickers = ['AAPL', 'MSFT', 'META']
tickers = st.multiselect("Elija un ticker o varios", lista_tickers, default=['AAPL'])
descargar = st.button("Descargar")

fecha_inicio = st.date_input("Fecha inicial", pd.to_datetime("2020-01-01"))
fecha_fin = st.date_input("Fecha final", pd.to_datetime("2023-12-31"))
inversion_inicial = st.number_input("Inversi√≥n inicial (USD)", min_value=1000, value=10000)
frecuencia = st.selectbox("Frecuencia temporal", ["Diaria", "Mensual"])

if descargar:
    if not tickers:
        st.warning("‚ö†Ô∏è Debes seleccionar al menos un ticker para descargar datos.")
    else:
        with st.spinner("üì• Descargando datos desde Yahoo Finance..."):
            data = yf.download(tickers, start=fecha_inicio, end=fecha_fin)["Adj Close"]
            st.success("‚úÖ Datos descargados correctamente.")
            st.dataframe(data.tail())
else:
    st.info("üëà Selecciona los activos y presiona **Descargar** para iniciar.")

# Descarga de datos

data = yf.download(tickers, start=fecha_inicio, end=fecha_fin)["Adj Close"]
st.subheader("üìä Datos hist√≥ricos descargados")
st.dataframe(data.tail())

# Visualizaci√≥n de precios

st.subheader("üìà Evoluci√≥n hist√≥rica de precios")
fig1, ax1 = plt.subplots(figsize=(10, 4))
data.plot(ax=ax1)
plt.title("Evoluci√≥n de precios ajustados")
plt.xlabel("Fecha")
plt.ylabel("Precio (USD)")
st.pyplot(fig1)

# C√°lculo de rendimientos

returns = data.pct_change().dropna()
mean_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252

# Estad√≠sticas generales
display(returns.describe().T)

# Escenario de inversi√≥n

st.sidebar.header("üí∞ Escenario de inversi√≥n")
escenario = st.sidebar.selectbox("Seleccione el tipo de portafolio", ["Conservador", "Moderado", "Agresivo"])

escenarios = {
    "Conservador": np.array([0.6, 0.3, 0.1])[:len(tickers)],
    "Moderado": np.array([0.4, 0.4, 0.2])[:len(tickers)],
    "Agresivo": np.array([0.2, 0.3, 0.5])[:len(tickers)]
}

weights = escenarios[escenario]
weights = weights / np.sum(weights)

# C√°lculos del portafolio

port_return = np.dot(weights, mean_returns)
port_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
sharpe_ratio = port_return / port_volatility

# Retorno acumulado y evoluci√≥n monetaria

returns["Portfolio"] = (returns[tickers] * weights).sum(axis=1)
valor_portafolio = (1 + returns["Portfolio"]).cumprod() * inversion_inicial

# Resultados

st.subheader(f"üìä Resultados del Portafolio ({escenario})")
st.write("**Pesos del Portafolio:**", dict(zip(tickers, weights.round(2))))
st.write(f"**Rendimiento Esperado:** {port_return:.2%}")
st.write(f"**Volatilidad Esperada:** {port_volatility:.2%}")
st.write(f"**Sharpe Ratio:** {sharpe_ratio:.2f}")

# Evoluci√≥n del valor monetario

st.subheader("üíµ Evoluci√≥n del valor del portafolio")
fig2, ax2 = plt.subplots(figsize=(10, 4))
valor_portafolio.plot(ax=ax2, color='green')
plt.title("Evoluci√≥n del valor monetario del portafolio")
plt.xlabel("Fecha")
plt.ylabel("Valor (USD)")
st.pyplot(fig2)

# Diagrama riesgo - retorno

st.subheader("üìä Diagrama Riesgo - Retorno")
fig3, ax3 = plt.subplots()
ax3.scatter(port_volatility, port_return, c='blue', s=100)
ax3.set_xlabel("Volatilidad (Riesgo)")
ax3.set_ylabel("Rendimiento Esperado")
ax3.set_title("Diagrama Riesgo - Retorno")
st.pyplot(fig3)

#  Correlaciones

st.subheader("üî• Matriz de correlaciones entre activos")
corr_matrix = returns[tickers].corr()
st.dataframe(corr_matrix)

fig4, ax4 = plt.subplots()
cax = ax4.imshow(corr_matrix, cmap="coolwarm", interpolation="nearest")
plt.title("Heatmap de Correlaciones")
plt.colorbar(cax)
ax4.set_xticks(range(len(corr_matrix)))
ax4.set_xticklabels(corr_matrix.columns, rotation=45)
ax4.set_yticks(range(len(corr_matrix)))
ax4.set_yticklabels(corr_matrix.columns)
st.pyplot(fig4)

# Visualizaci√≥n del portafolio

st.subheader("ü•ß Distribuci√≥n del portafolio por escenario")

fig, ax = plt.subplots()
ax.pie(weights, labels=lista_tickers, autopct="%1.1f%%", startangle=90)
ax.set_title(f"Distribuci√≥n del portafolio ({escenario})")
st.pyplot(fig)

# Distribuci√≥n de pesos por escenario

st.subheader("üìä Comparaci√≥n de escenarios de inversi√≥n")

fig_all, axs = plt.subplots(1, 3, figsize=(12, 4))
for i, (nombre, w) in enumerate({
    "Conservador": np.array([0.6, 0.3, 0.1])[:len(tickers)],
    "Moderado": np.array([0.4, 0.4, 0.2])[:len(tickers)],
    "Agresivo": np.array([0.2, 0.3, 0.5])[:len(tickers)]
}.items()):
    w = w / np.sum(w)
    axs[i].pie(w, labels=tickers, autopct='%1.1f%%', startangle=90)
    axs[i].set_title(nombre)

plt.suptitle("Distribuci√≥n de pesos por tipo de portafolio")
st.pyplot(fig_all)